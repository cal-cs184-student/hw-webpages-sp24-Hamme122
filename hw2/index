<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Project2_html</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="433ed67f-dde9-4357-ae7e-91799d4b505a" class="page sans"><header><h1 class="page-title">Project2_html</h1><p class="page-description"></p></header><div class="page-body"><nav id="e7db84ad-21f4-4984-8679-d305f519de8a" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a4ed7da1-6792-472d-9ee0-94b04e8570c1">Overview</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#76e2c2f2-db4b-4623-9a92-04ca1e33007a">Part 1: Bezier curves with 1D de Casteljau subdivision</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1a50a071-27d7-4a95-beb3-14c16c8f8bea">Part 2: Bezier surfaces with separable 1D de Casteljau</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#aafe402e-0853-4fdb-950c-d5eb9c163314"><strong><strong>Part 3: Area-Weighted Vertex Normals</strong></strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8bd536c8-1353-4b02-b2cf-379b85cca579"><strong><strong>Part 4: Edge Flip</strong></strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#752dff86-5b44-4160-8ef9-938a31a2df15"><strong><strong>Part 5: Edge Split</strong></strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bdaefe28-ef2f-4f18-a661-87c4c6efaad6">Part 6: Looping Subdivision <strong><strong>for Mesh Upsampling</strong></strong></a></div></nav><h2 id="a4ed7da1-6792-472d-9ee0-94b04e8570c1" class="">Overview</h2><p id="51e3533d-20bf-40b9-8431-8c6427a00d93" class="">In this project, we learned and implemented the creation and manipulation of Bezier curves and surfaces, the calculation of area-weighted vertex normals, the efficient mesh manipulation such as edge flipping and splitting in the halfedge data structure, and the application of loop subdivision for mesh refinement. We also learned a lot for the process of debugging.</p><h2 id="76e2c2f2-db4b-4623-9a92-04ca1e33007a" class="">Part 1: Bezier curves with 1D de Casteljau subdivision</h2><p id="dab2d9e5-b44c-46f9-b51a-fab7a7d77dcd" class="">De Casteljau&#x27;s algorithm is a recursive approach for evaluating Bezier curves, which recursively linearly interpolates between the control points of the Bézier curve<strong> until a single point is obtained.</strong> This point is on the Bezier curve for the given parameter t, which varies from 0 to 1. </p><p id="98384ff8-2bb8-4c86-a67c-92da4afffdd6" class="">In our implementation, we finished the <code>evaluateStep</code> function, where for a given set of points, it computes the next set of intermediate points by linearly interpolating between each pair of adjacent points using the parameter <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span><span>﻿</span></span>. In every call to this function, we establish a loop which iterates through each pair of adjacent points in the input vector, linearly interpolates between them, and stores the result in a new vector to return.</p><p id="0c85c79d-7e14-4918-a6e2-2f6abfb9cf30" class="">Below we show our result of a bezier curve with <strong>6</strong> control points. We can see each step of the evaluation from the original control points down to the final evaluated point. And we also show the result after moving the original control points around and modifying the parameter <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span><span>﻿</span></span>.</p><div id="f931380d-356d-4e72-b2c7-0995139fd318" class="column-list"><div id="63753aac-8684-4d77-82cc-2e13588203df" style="width:50%" class="column"><figure id="c462625e-d65b-4d92-b519-67821ac40c28" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve1.png"><img style="width:384px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve1.png"/></a><figcaption>Level 1 + Curve:</figcaption></figure></div><div id="127b4b11-8dad-4bc4-8452-86889bb421cd" style="width:50%" class="column"><figure id="96d4aecc-f85a-4d0a-8236-09fad24f1e0e" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve2.png"><img style="width:961px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve2.png"/></a><figcaption>Level 2 + Curve:</figcaption></figure></div></div><div id="18e8a9f1-8d53-482d-838f-d10c16a566a3" class="column-list"><div id="eddeb8f8-e3e0-4241-b555-aae58424d2ea" style="width:50%" class="column"><figure id="c50f2019-b731-4869-a4ec-277f81cda6b3" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve3.png"><img style="width:956px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve3.png"/></a><figcaption>Level 3 + Curve:</figcaption></figure></div><div id="8f68145a-39e3-4fcd-8e7a-a0b7fbe86e6a" style="width:50%" class="column"><figure id="60f37315-c31f-490c-91b2-58a3044484ec" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve5.png"><img style="width:953px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve5.png"/></a><figcaption>Level 4 + Curve</figcaption></figure></div></div><div id="3bcfe9ea-dd95-4f90-98c8-b527f1d76e14" class="column-list"><div id="87d374a1-a1a0-402d-8c40-26e73532021b" style="width:50%" class="column"><figure id="9ba388b9-0452-477d-b439-9bf11abd4048" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve5%201.png"><img style="width:953px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve5%201.png"/></a><figcaption>Level 5 + Curve:</figcaption></figure></div><div id="1daedd1c-cfc1-4562-8fce-674a08da9b32" style="width:50%" class="column"><figure id="45c3c36d-6fbb-4a09-9590-0ac0ec36b0a8" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve6.png"><img style="width:947px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/curve6.png"/></a><figcaption>Different control points &amp; parameter t</figcaption></figure></div></div><h2 id="1a50a071-27d7-4a95-beb3-14c16c8f8bea" class="">Part 2: Bezier surfaces with separable 1D de Casteljau</h2><p id="b68d7d82-e680-4492-b3cb-9f01939a8bed" class="">De Casteljau&#x27;s algorithm extends to Bezier surfaces by applying the same principle used for Bezier curves, but in two dimensions. For a Bezier surface, control points are arranged in a grid (or a mesh) rather than a single sequence. </p><p id="b1bf2b4b-31ab-47cf-83a7-5a826e114bbe" class="">In our implementation, we finished 3 functions here. This first function <code>BezierPatch::evaluateStep</code> linearly interpolate between original control points to simplify them, creating intermediate points. The second function <code>BezierPatch::evaluate1D</code>  loops through the levels of points (the amplification) until we get a single point that represents a specific location on the Bezier curve or surface. And the last function <code>BezierPatch::evaluate</code> loops through the whole mesh, by taking the control point of each curve that we calculated previously and then calculating the singular point between them to create another singular control point that thus works in both the x and y direction.</p><ul id="b04d5389-6183-4d12-932c-572996269598" class="toggle"><li><details open=""><summary>As such we use 3 functions here to represent 3 general ___ to conceive points. 1 level, looping through all of the original points, between the original points, simplifying them, 2 looping through the levels of points (the amplification) until you get one point, and 3 level, looping through the whole mesh, by taking the control point of each curve that we calculated previously and calculating the singular point between them to create another singular control point that thus works in both the x and y direction.</summary></details></li></ul><p id="dec03bb9-7c97-4424-8708-8a3e2def059c" class="">Our result of <code>Teapot.bez</code>is shown below:</p><figure id="15f53e57-24ca-4b0c-a6d9-439eb05da24e" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Teapot.png"><img style="width:432px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Teapot.png"/></a><figcaption>Result of <code>Teapot.bez</code></figcaption></figure><h2 id="aafe402e-0853-4fdb-950c-d5eb9c163314" class=""><strong><strong>Part 3: Area-Weighted Vertex Normals</strong></strong></h2><p id="861e6f18-43a9-49db-baa9-856062c525f6" class="">In the process of implementing the area-weighted vertex normals, we utilized an iterative approach that loops through all the neighboring triangles of a given vertex. For each triangle, we find its three vertexes first and then we calculate the normal by taking the cross product of two edges emanating from the vertex. We also calculate the triangles’ area using half of the cross product. Then each normal is then scaled by the area of the triangle, and we got the final vertex normal by normalizing this sum. The shading results with and without vertex normals are shown below:</p><div id="a1ad8e90-573a-4b9f-a4a1-b86265361661" class="column-list"><div id="a6acc16a-598e-470c-aedf-de341b99808a" style="width:50%" class="column"><figure id="a823e34f-5c73-4bef-9be0-e466b4ea1eed" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled.png"><img style="width:960px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled.png"/></a><figcaption>Teapot shading without vertex normals</figcaption></figure></div><div id="fae7ca8b-87a2-4ccd-bb0d-a2ce01c1268b" style="width:50%" class="column"><figure id="9b8935c8-8fb1-439d-895d-ee56e520bb8e" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%201.png"><img style="width:958px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%201.png"/></a><figcaption>Teapot shading with vertex normals</figcaption></figure></div></div><h2 id="8bd536c8-1353-4b02-b2cf-379b85cca579" class=""><strong><strong>Part 4: Edge Flip</strong></strong></h2><p id="448fd581-8b5d-4d24-b62e-887e9e0fa9aa" class="">In the process of implementing the edge flip, we first check for boundary conditions. If <code><strong>e0-&gt;isBoundary()</strong></code> returns true, we return immediately. Then we draw every element containing ten half-edges, four vertexes, five edges, and two faces and reassign every element’s pointer. The results before and after the edge flip are shown below:</p><div id="4e741f1c-6874-4626-883c-1a3b254cf997" class="column-list"><div id="070636ff-0b28-4e47-bd8c-6ae3c54e0989" style="width:50%" class="column"><figure id="3b1582a9-4c73-4370-b632-b07427fef28e" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%202.png"><img style="width:955px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%202.png"/></a><figcaption>Teapot without edge flip</figcaption></figure></div><div id="741835ed-87d4-437c-b26a-ed54b453fb94" style="width:50%" class="column"><figure id="a1c37c52-58d8-4e54-af8e-4bdecd439cbd" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%203.png"><img style="width:956px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%203.png"/></a><figcaption>Teapot after some edge flip</figcaption></figure></div></div><p id="9cb65e1c-f0cb-4fd8-9716-498f8bf82e21" class="">When debugging our code, the first problem is that we can’t use <code><strong>EdgeCIter</strong></code>to define an edge. This is because we need to change the pointer of the edge, so we should use <code><strong>EdgeIter</strong></code>, which will not define this edge as a const. The second problem is that we shouldn’t define e0 again because it was the input of our function🥲. And because we reset all pointers of all elements, no more problems occur.</p><h2 id="752dff86-5b44-4160-8ef9-938a31a2df15" class=""><strong><strong>Part 5: Edge Split</strong></strong></h2><p id="8154ab33-d977-4f36-ae90-f148c8939751" class="">In the process of implementing the edge split, firstly, as shown below, we marked the relevant half-edges, vertices, edges, and faces surrounding the edge to be split. Then we identify the origin elements and allocate new elements. And the new vertex is positioned at the midpoint of the original edge. Finally, we reassign elements, ensuring the mesh remains manifold and returns the midpoint.</p><figure id="ab86e28e-89c9-49ef-a557-fced1402f642" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%204.png"><img style="width:384px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%204.png"/></a><figcaption>Mark of the triangle after the split</figcaption></figure><p id="282586f4-c7cb-4670-87a7-7b2e4768b19b" class="">The results before and after some edge splits are shown below:</p><div id="20cbc055-24ee-4302-a39b-7e9234fca690" class="column-list"><div id="0f593aba-d737-4ba2-8f21-3fcb67053484" style="width:50%" class="column"><figure id="922354ea-d0f1-49d2-b084-b29a10c3d6a7" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%205.png"><img style="width:959px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%205.png"/></a><figcaption>Before some edge splits</figcaption></figure></div><div id="3dbf7f2c-346b-4344-9836-e65ee36523a4" style="width:50%" class="column"><figure id="41af8832-0607-469c-a730-1b4cc28e5acd" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%206.png"><img style="width:958px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%206.png"/></a><figcaption>After some edge splits</figcaption></figure></div></div><p id="7c20bcb7-c741-46df-89c4-c19d3a6afb8f" class="">The results before and after a combination of both edge splits and edge flips are shown below:</p><div id="75ec2b90-cfd6-4743-8e99-a85c7d6cc102" class="column-list"><div id="045ca7f8-80e3-48da-9d80-f72074be9a84" style="width:50%" class="column"><figure id="44de9dbe-8b56-447f-9336-dcb40b3b856a" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%205.png"><img style="width:959px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%205.png"/></a><figcaption>Before a combination of both edge splits and edge flips </figcaption></figure></div><div id="8c29d554-2528-482a-b808-8b51e658d6d3" style="width:50%" class="column"><figure id="c24888df-0a4d-4ffe-8a37-d6799004f3dc" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%207.png"><img style="width:958px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%207.png"/></a><figcaption>After a combination of both edge splits and edge flips </figcaption></figure></div></div><p id="2d474926-a376-4766-88cb-51411c69b963" class="">The problem I encountered in debugging was that I only defined the midpoint, forgetting to calculate its position🥲. This resulted in the hole.</p><p id="4557cca1-b7b3-4503-b774-844352efa9b4" class="">And we have also implemented support for boundary edges. We marked different elements using the method shown below:</p><figure id="fabc91bd-d590-4d33-903d-676ddef33bc5" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%208.png"><img style="width:288px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%208.png"/></a></figure><p id="a5e72dd0-0ede-4bda-b79c-4a18f14cf1cd" class="">Then just like the steps before, we identified the origin elements allocated new elements, and then reassigned them. The results from <code>beetle.dae</code> are shown below. We can see the purple line in the car, only splitting in half the face that is non-boundary.</p><div id="fe9473a8-be60-4204-8b85-75bccff47c41" class="column-list"><div id="dd8dd432-97b8-4c28-aece-e91a581fefee" style="width:50%" class="column"><figure id="f8f7cbab-c265-4417-9e87-4b2846c9bbe0" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%209.png"><img style="width:956px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%209.png"/></a><figcaption>Before some edge splits in the boundary</figcaption></figure></div><div id="5045c356-169a-434c-a966-1f1a29a83a5c" style="width:50%" class="column"><figure id="817d6b08-50b7-46ad-8000-f9b79e56353e" class="image"><a href="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%2010.png"><img style="width:959px" src="Project2_html%20433ed67fdde94357ae7e91799d4b505a/Untitled%2010.png"/></a><figcaption>After some edge splits in the boundary</figcaption></figure></div></div><h2 id="bdaefe28-ef2f-4f18-a661-87c4c6efaad6" class="">Part 6: Looping Subdivision <strong><strong>for Mesh Upsampling</strong></strong></h2><ul id="9246d74a-fed2-4843-be16-83461d506a0d" class="bulleted-list"><li style="list-style-type:disc">Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.</li></ul><p id="aff5f267-696a-4fde-9dcd-326a5994695c" class="">We implemented loop subdivision by using four separate four loops that go through the whole mesh. The first and second for loop work to find the new positions of each new vertex, which allows for the averaging out or smoothing effect. For the positions of the ____. The third loop focuses on splitting each edge into 2 and the final for loop flips the edges appropriately, cleaning up the mesh. </p><ul id="1214001d-fff0-4cc4-a378-331cdae72547" class="bulleted-list"><li style="list-style-type:disc">Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?</li></ul><p id="06200d08-7b49-4be3-b9df-7c47ae159f38" class="">After the loop subdivision, the sharp corners and edges start to become curves and smooth out. You can probably reduce this effect by having more splits as well ____ that are closer together near the corners or edges so that t</p><ul id="4e2af668-1744-4d11-b985-961a690e6c16" class="bulleted-list"><li style="list-style-type:disc">Load <code>dae/cube.dae</code>. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also, explain how your pre-processing helps alleviate the effects.</li></ul><p id="727cfb58-6efb-45df-8023-f4b5caa628e1" class="">Pre-processing can help alleviate these effects as our current algorithm averages the points positions as we do each level of subdivision. But if we were to divide up our points before-hand we would be able to average out more based on more points, thus keeping the shape of the cube better. In terms of making more symmetric, we can change the way that we split the edges so that both sides of the mesh are the same, rather than having it lean to one side lie before. </p><p id="0f6afe94-7e5b-4ef6-ac05-990561cbcecf" class="">
</p><p id="eb62ee27-8f75-493b-b60e-c0d3d7f0c9d8" class="">
</p><p id="0bf2da25-5474-441f-a1ec-f1bcc0c631d0" class="">
</p><p id="394fdc06-cf3d-4eb6-94ed-7cb296d28e0e" class="">
</p><p id="ede3d76a-2452-4cf3-af00-40be1c723b8f" class="">Code:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4face68a-6d2a-4ebc-a0f1-73e636331b74" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">// 3. Split every edge in the mesh, in any order. For future reference, we&#x27;re also going to store some
// information about which subdivide edges come from splitting an edge in the original mesh, and which edges
// are new, by setting the flat Edge::isNew. Note that in this loop, we only want to iterate over edges of
// the original mesh---otherwise, we&#x27;ll end up splitting edges that we just split (and the loop will never end!)


  // loop through each edge for this specific vertex
  // while the curr half_edge != intial half_edge of this group of vertices

    vector&lt;EdgeIter&gt; originalEdges;
    for (EdgeIter e = mesh.edgesBegin(); e != mesh.edgesEnd(); e++) {
        originalEdges.push_back(e);
    }

    cout &lt;&lt; mesh.nHalfedges();
    for (auto e = originalEdges.begin(); e != originalEdges.end(); e++) {

        // VertexIter curr_vertex = (*e)-&gt;halfedge()-&gt;vertex();
        // VertexIter connected_vertex = e-&gt;halfedge()-&gt;twin()-&gt;vertex();

        // Start time
        auto start = std::chrono::high_resolution_clock::now();

        VertexIter new_vertex = mesh.splitEdge(*e);
        new_vertex-&gt;isNew = true;
        new_vertex-&gt;newPosition = (*e)-&gt;newPosition;
        new_vertex-&gt;halfedge()-&gt;edge()-&gt;isNew = false;
        new_vertex-&gt;halfedge()-&gt;twin()-&gt;next()-&gt;edge()-&gt;isNew = true;
        new_vertex-&gt;halfedge()-&gt;next()-&gt;next()-&gt;edge()-&gt;isNew = true;
        new_vertex-&gt;halfedge()-&gt;twin()-&gt;next()-&gt;twin()-&gt;next()-&gt;edge()-&gt;isNew = false;


        auto stop = std::chrono::high_resolution_clock::now();

        auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(stop - start);


        // std::cout &lt;&lt; &quot;Time taken by iteration: &quot; &lt;&lt; duration.count() &lt;&lt; &quot; microseconds&quot; &lt;&lt; std::endl;


    }

// 4. Flip any new edge that connects an old and new vertex.
// 5. Copy the new vertex positions into final Vertex::position.

// initilize curr half_edge and half_edge counter
    //mesh.flipEdge(mesh.edgesBegin());
for (EdgeIter e = mesh.edgesBegin(); e != mesh.edgesEnd(); e++) {
    VertexIter curr_vertex = e-&gt;halfedge()-&gt;vertex();
    VertexIter connected_vertex = e-&gt;halfedge()-&gt;twin()-&gt;vertex();

    if (e-&gt;isNew == true) {
        // if curr vertex is old and connecting vertex new then flip curr_edge
        // || curr_vertex-&gt;isNew &amp;&amp; !connected_vertex-&gt;isNew
        // check one new! isEqual to other new
        if (curr_vertex-&gt;isNew != connected_vertex-&gt;isNew) {
           mesh.flipEdge(e);
        }
    }
}
/*
for (auto v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++)
{
    v-&gt;position = v-&gt;newPosition;
}
*/
</code></pre><p id="2e89424d-66d1-470f-8780-d7c185c208b5" class="">There are some problem there:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8b3293df-a25d-4e75-9aa2-deb9f7494ced" class="code"><code class="language-C++">
for (auto v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++)
{
	// find out if it&#x27;s an new vertex located on an edge or if it&#x27;s an old vertex
	// if it&#x27;s an old vertex, set v-&gt;position = v-&gt;newPosition;
	// if it&#x27;s a new vertex, set v-&gt;position = v-&gt;edge-&gt;newPosition;
    v-&gt;position = v-&gt;newPosition;
}

//kind of like this
 for (auto v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++)
 {
     if (v-&gt;isNew) {
         v-&gt;position = v-&gt;halfedge()-&gt;edge()-&gt;newPosition;
     }
     else {
         v-&gt;position = v-&gt;newPosition;
     }
 }
</code></pre><p id="5514c72d-ce90-4ffe-8e37-b982f0e5ba29" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>
